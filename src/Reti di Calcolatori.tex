\documentclass[11pt,a4paper]{article}

\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{xcolor}
\usepackage{listings}


\theoremstyle{definition}
\newtheorem{definition}{Definizione}[section]


\begin{document}
\title{Reti di Calcolatori a.a. 2019/2020}
\author{Francesco Iannelli}
\date{September 16, 2019}
\maketitle

\newpage

\tableofcontents
\newpage

\section{Introduzione al corso}
email: federica.paganelli@unipi.it\newline
modalità d'esame: prova scritta (compitini) e orale (facoltativo) più\newline
laboratorio che prevede progetto e orale. \newline
\underline{\textbf{N.B. Si accede alla prova orale di laboratorio solo dopo aver passato lo scritto.}}

\section{Cenni di modelli stratificati}
Sono architetture di comunicazione a strati. \newline
Concetti generali:
\begin{itemize}
	\item Stratificazione
	\item Information hiding
	\item Separation of concerns
\end{itemize}
Vantaggi della stratificazione:
\begin{itemize}
	\item \textbf{Facilità di progettazione.}
	\item \textbf{Facilità di manutenzione.}
	\item \textbf{Possibilità di riciclo.}
\end{itemize}
Due modelli: \textbf{ISO/OSI} (approccio top-down) e \textbf{Stack TCP/IP} (approccio bottom-up), quest ultimo vincente.\newline
Idea chiave: \underline{suddivisone in sottoproblemi.}
\begin{figure}[!h]
	\includegraphics[scale=0.8]{Immagini/Modelli_Strat.png}
	\centering
	\caption{Modello stratificato}
\end{figure}

\pagebreak

\subsection{Livello applicativo}
Fanno parte del livello applicativo:
\begin{itemize}
	\item Identificativi delle risorse: URL, URI e URN.
	\item Il web: user agents, protocollo http.
	\item Protocollo FTP.
	\item TELNET: servizio di terminale virtuale.
	\item Posta elettronica.
	\item Sistema dei nomi DNS a dominio e la risoluzione dei nomi: iterativa e ricorsiva.
	\item molto altro ancora...
\end{itemize}

\subsection{Livello di trasporto}
Due tecnologie degne di nota:
\begin{enumerate}
	\item Protocollo \textbf{TCP}: \textbf{connection-oriented}, \textit{orientato alla connessione}.
	\item Protocollo \textbf{UDP}: \textbf{connection-less}, molto più leggero, prende dati applicativi e li affida allo strato IP, \underline{NON} da garanzie di consegna nè di ordine.
\end{enumerate}

\subsection{Livello rete}
Nel livello rete si ricava un percorso dall'host sorgente all'host destinatario usando le informazioni che si trovano nell'IP.\newline
Verrà trattato il protocollo Ipv4 e introdotto il protocollo Ipv6.

\subsection{Livello link}
Si occupa di gestire il collegamento tra due nodi \textbf{adiacenti}.
La tecnologia principale è l'\textbf{ethernet}.
\pagebreak

\section{Introduzione alle reti}
\textit{Cos'è una rete? Quante tipologie di reti ci sono? Cos'è internet?}

\theoremstyle{definition}
\begin{definition}
	Una \textbf{rete} è un'interconnessione di dispositivi in grado di scambiarsi e interpretare le informazioni. Comprende sistemi terminali e intermedi: \textit{e.g. router, switch e modem.}
\end{definition}
I sistemi terminali si possono dividere in due tipi: \textbf{host} e \textbf{server}, sull'host girano le applicazioni utente mentre il server esegue programmi che forniscono servizi applicativi ad applicazioni. \newline \textit{N.B. il termine host può essere usato per indicare anche un server. \newline L'host, infatti, può essere sia un server sia il terminale di un utente che esegue un'applicazione client, più generalmente \textbf{l'host è una macchina}.}

\theoremstyle{definition}
\begin{definition}
	Una rete è formata da \textbf{dispositivi} e da \textbf{tecnologie}.
\end{definition}

\subsection{LAN}
Acronimo di \textbf{L}ocal \textbf{A}rea \textbf{N}etwork, è
una rete di area geografica limitata collegata attraverso una tecnologia ethernet \textbf{bus} o ethernet \textbf{switch}:
\begin{figure}[!h]
	\includegraphics[scale=0.6]{Immagini/LAN.png}
	\centering
\end{figure}
Ciascun host ha un cavo che lo collega allo switch e a ogni porta dello switch corrisponde un host. Lo \textbf{switch} possiede una tecnologia di autoapprendimento ed è una componente del \textbf{livello link}.
\newpage

\subsection{WAN}
Acronimo di \textbf{W}ide \textbf{A}rea \textbf{N}etwork, è una rete di area geografica estesa: è composta da due o più reti collegate tramite un mezzo di trasmissione. Le reti coinvolte potrebbero anche essere reti LAN. \textit{(e il link potrebbe essere affittato a un'azienda da un operatore di telefonia).}
\begin{figure}[!h]
	\includegraphics[scale=0.6]{Immagini/WAN_Switch.png}
	\centering
	\caption{Un esempio di WAN a cavo condiviso e a commutazione.\newline
		Queste WAN permettono l'esistenza di \textbf{percorsi alternativi} e la \textbf{divisione del traffico}. Una \textbf{WAN punto punto} invece ha \textbf{solo} 2 punti di terminazione.}
\end{figure}


\subsection{Internetwork}
L'internetwork è un sistema in cui ci sono più reti composte, capaci di scambiarsi informazioni e collegate. Concettualmente è una WAN ma è più complicata.\newline
I dispositivi che la compongono si distinguono in \textbf{sistemi terminali}
e dispositivi come gli \textbf{switch} e i \textbf{routers} che si trovano nel percorso tra i sistemi sorgente e i sistemi destinazione.
\begin{figure}[!h]
	\includegraphics[scale=0.4]{Immagini/Internetwork.png}
	\centering
	\caption{Una internetwork.}
\end{figure}\newline
\textit{Problema: come mandare informazioni da un host a un altro?}


\subsubsection{Reti a commutazione di circuito}
Nelle \textbf{reti a commutazione di circuito} le \textbf{risorse} sono \textbf{riservate end to end} per ogni connessione. Risulta quindi necessario il \textbf{setup della comunicazione} per instaurare la connessione ed elargire le risorse.\newline
La risorsa non è tutto il link, bensì si considerano come risorse la capacità o la larghezza di banda porzionate per ogni connessione. Le risorse assegnate rimangono inattive se non utilizzate (\textit{e.g. telefonata}). I dispositivi mantengono lo stato della connessione. \textbf{Le performance sono garantite}. La capacità delle linee (\textit{link}) cambia a seconda della loro funzione all'interno della rete. Il \textbf{punto debole} delle reti a commutazione di circuito è la \textbf{poca flessibilità nel dispiegamento delle risorse}.


\subsubsection{Reti a commutazione di pacchetto}
Nelle \textbf{reti a commutazione di pacchetto} gli utenti inviano pacchetti che condividono le risorse del canale di comunicazione. \textbf{Non c'è} quindi \textbf{un canale dedicato} ai pacchetti di un singolo utente. La principale differenza rispetto alla commutazione di circuito risiede nell'implementazione della logica dei dispositivi di interconnessione, ovvero:
\begin{itemize}
	\item \textbf{Commutazione di Circuito}: avviene il \textbf{setup} della connessione dove  si prealloca l’utilizzo del collegamento trasmissivo con collegamenti
	      garantiti.
	\item \textbf{Commutazione di Pacchetto}: non viene instaurata una connessione bensì le informazioni necessarie si trovano all'interno dei pacchetti stessi, non ci sono informazioni di connessione memorizzate nei dispositivi coinvolti.
\end{itemize}
Nelle reti a commutazione di pacchetto quindi le risorse vengono usate a seconda della necessità. Possono quindi verificarsi situazioni di contesa delle risorse e sussiste il pericolo di congestione o di perdita dei pacchetti nel caso in cui la dimensione della coda del router non fosse sufficiente a contenere il flusso dei pacchetti entranti: il commutatore (\textit{router}) deve infatti ricevere l’intero
pacchetto prima di poter cominciare a trasmetterlo sul collegamento in uscita (\textit{\textbf{store and forward}}). \textbf{Non sono} quindi \textbf{garantite le prestazioni}.
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Packet_Switch.png}
	\centering
	\caption{Rete a commutazione di pacchetto. Da notare le diverse capacità dei link.}
\end{figure}
\newpage
\subsubsection{Packet Switch e Circuit Switch a confronto}
Vi sono 35 utenti su una rete con 100 Kbit/s di connessione e un link da 1 Mbit/s.
Ogni utente è attivo solo il 10\% del tempo.\newline
Con una \textbf{rete a commutazione di circuito} si riescono a gestire \textbf{solo} 10 utenti.\newline
Con una \textbf{rete a commutazione di pacchetto} si hanno i seguenti casi:
\begin{enumerate}
	\item 10 o meno utenti attivi: nessun problema.
	\item Più di 10 utenti attivi: ritardo.
\end{enumerate}
Tuttavia che gli utenti siano tutti e 35 attivi contemporaneamente è poco probabile (infatti $P(35) = 0.0004$).
Se ne deduce che la rete a commutazione di pacchetto riesce a gestire tutti gli utenti contemporaneamente nella maggior parte dei casi.

Nonostante il risultato ottenuto non si deve pensare che la rete a  commutazione di circuito sia obsoleta. Nel corso degli anni infatti le due tecnologie sono state \textbf{integrate} in vari modi.\newline
La commutazione di circuito infatti è usata nella telefonia fissa (\textit{PSTN: public switch telephone network}) per i servizi voce, la commutazione di pacchetto invece per i dati.\newline
Nelle reti ottiche di prima e seconda generazione si usano entrambe le tecnologie.

\subsubsection{Circuiti virtuali}
I circuiti virtuali funzionano nel seguente modo: viene stabilito un path tra host sorgente e host destinazione e tutti i pacchetti di un certo flusso seguono lo \textbf{stesso} path.
\subsubsection{Datagram Network}
Con \textbf{datagram} si indica un'entità informativa autocontenuta che contiene le informazioni sufficienti per essere indirizzata alla destinazione senza comunicazioni aggiuntive tra sorgente e destinazione: \textbf{non è quindi detto} che pacchetti di uno stesso flusso seguano lo stesso path sulla rete.
\newpage

\subsection{Internet}
\textit{Come interconnettere reti già esistenti?}\newline
\theoremstyle{definition}
\begin{definition}
	Una internet (con i minuscola) è una rete costituita da
	due o più reti interconnesse.
\end{definition}
La internet più famosa è chiamata \textbf{Internet} (con i maiuscola) ed è composta da migliaia di reti interconnesse. Ogni rete connessa ad Internet deve usare il protocollo IP e rispettare certe convenzioni su come vengono assegnati nomi e indirizzi.
Si possono facilmente aggiungere nuove reti. \newline Tuttavia è impensabile avere un link fisico tra ogni host, si hanno invece numerosi
dispositivi di interconnessione che permettono la comunicazione da un host all'altro e da un router all'altro.\newline
Uno scorcio delle \textbf{componenti di Internet}:
\begin{itemize}
	\item Miliardi di dispositivi interconnessi (e.g. hosts, end systems).
	\item Link di comunicazione (e.g. fibre ottiche, doppini telefonici,
	      cavi coassiali, onde radio).
	\item Routers: instradano pacchetti \textit{(sequenze)} di dati attraverso la rete.
\end{itemize}

\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Internet.png}
	\centering
	\caption{Una porzione di Internet}
\end{figure}

Uno scorcio delle \textbf{entità software} di Internet:

\begin{itemize}
	\item Applicazioni e processi che elaborano le informazioni.
	\item \textbf{Protocolli} che regolamentano la trasmissione e la ricezione di informazioni e.g. TCP, IP, HTTP, FTP, PPP.
	\item Interfacce: verranno definite in seguito, sono le \textit{“membrane”} che separano gli \textit{"strati"}.
\end{itemize}

\subsubsection{Servizi}
L’\textbf{infrastruttura di comunicazione} consente il funzionamento delle applicazioni distribuite per scambio di informazioni \textit{(e.g. WWW, email, giochi, e-commerce, database, controllo remoto, ecc).}\newline
Lo \textbf{stack protocollare} offre il servizio di connessione. Vi sono due approcci:
\begin{enumerate}
	\item \textbf{Connection-less}: I dati vengono trasferiti \textbf{senza} stabilire una
	      connessione, non c'è nessuna garanzia di ordine e consegna. \textit{Ogni pacchetto ha una vita a sè.}
	\item \textbf{Connection-oriented}: Prevede l'\textbf{instaurazione della connessione}, il trasferimento dei dati e, in seguito, la chiusura della connessione. Garantisce integrità, completezza e ordine.
\end{enumerate}

\subsubsection{IETF/RFC/ICANN}

\theoremstyle{definition}
\begin{definition}
	L'IETF (Internet Engineering Task Force) è l’organismo che studia e sviluppa i protocolli in uso su Internet. Si basa su gruppi di lavoro a cui chiunque può accedere.
\end{definition}

\theoremstyle{definition}
\begin{definition}
	RFC/STD (Request For Comments \& STanDards) sono i documenti \textit{“ufficiali” } che descrivono i protocolli usati su Internet. Sono pubblicamente accessibili in rete.
\end{definition}

\theoremstyle{definition}
\begin{definition}
	ICANN (Internet Corporation for Assigned Names and Numbers) È un ente internazionale che coordina il sistema dei nomi di dominio (DNS), assegna i gruppi di indirizzi di rete, identificativi di protocollo e ha funzioni di controllo (blando) dello sviluppo di Internet.
\end{definition}

\subsubsection{Rete di accesso}
Internet è una internetwork che consente a qualsiasi utente
di farne parte. L’utente, tuttavia, deve essere fisicamente collegato a un
ISP (\textit{internet service provider}).
\theoremstyle{definition}
\begin{definition}
	Il collegamento che connette l'utente al primo router di internet è detto \textbf{rete di accesso}, suddetto collegamento può essere effettuato tramite rete telefonica, rete wireless o tramite accesso diretto.
\end{definition}

\newpage

\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Internet_Concept.png}
	\centering
	\caption{Un modello concettuale di Internet}
\end{figure}

\section{Metriche di riferimento}
\textit{Come misurare le prestazioni di una rete?}\newline

\theoremstyle{definition}
\begin{definition}
	La \textbf{larghezza di banda} o \textbf{bandwidth} è la larghezza dell'intervallo di frequenze utilizzato dal sistema trasmissivo.
\end{definition}

\theoremstyle{definition}
\begin{definition}
	Il \textbf{bit rate} o \textbf{trasmission rate} è la quantità di dati che possono essere trasmessi o ricevuti nell'unità di tempo. [e.g. bps = bit/s]\newline
	Il bitrate dipende dalla tecnica trasmissiva ed è proporzionale alla larghezza di banda.
\end{definition}

\theoremstyle{definition}
\begin{definition}
	Il \textbf{throughput} è la quantità di traffico che arriva realmente a destinazione nell'unità di tempo, al netto di perdite sulla rete,
	del funzionamento dei protocolli etc.
\end{definition}

\theoremstyle{definition}
\begin{definition}
	La \textbf{latenza} o \textbf{latency} è il tempo che passa dal momento in cui il primo bit parte dalla sorgente al momento in cui l'intero messaggio arriva a destinazione. \newline

	\fbox{\centering{$L = r_{propagazione} + r_{trasmissione} + r_{accomodamento} + r_{elaborazione}$}}
\end{definition}
\newpage

\subsection{Ritardi}
Il ritardo introdotto da un nodo è la somma di questi 4 ritardi:
\begin{figure}[!h]
	\includegraphics[scale=0.7]{Immagini/Ritardi.png}
	\centering
	\caption{Una visione di contesto}
\end{figure}

\subsubsection{Ritardo di elaborazione del nodo}
Il ritardo di elaborazione \textbf{è causato dall'elaborazione del percorso} (ovvero dove inoltrare il pacchetto scegliendo il percorso \textit{"migliore"}) \textbf{e dal controllo di errori sui bit}, è \textbf{tipicamente piccolo e trascurabile}.

\subsubsection{Ritardo di accodamento}
Il ritardo di accodamento \textbf{è il tempo che un pacchetto passa nella coda del router}, dipende dall'intensità e dal tipo di traffico. I pacchetti si accodano nei buffer dei router se il tasso di arrivo dei pacchetti eccede la capacità del collegamento di inoltrarli. Se non ci sono spazi liberi i pacchetti in arrivo vengono scartati.

\subsubsection{Rtardo di trasmissione}
Il ritardo di trasmissione \textbf{è il tempo impiegato a trasmettere un pacchetto intero} sul link.\newline
$R$ = rate di trasmissione del collegamento.\newline
$L$ = lunghezza del pacchetto.\newline
\centerline{$r_{trasmissione} = \frac{L}{R}$}

\subsubsection{Ritardo di propagazione}
Il ritardo di propagazione \textbf{è il tempo impiegato da un bit per essere propagato da un nodo (router) all'altro}.\newline
$d$ = lunghezza del collegamento fisico\newline
$s$ = velocità di propagazione del collegamento fisico \newline
\centerline{$r_{propagazione} = \frac{d}{s}$}

\subsection{Esempio}
Si consideri l'invio di un file di 1 MBit su un datalink di lunghezza 4800km:\newline
$d = 4800\times10^3 m$ \newline
$s = 3\times10^3 m/s$ \newline
Si calcoli il ritardo di propagazione. \newline
Soluzione:\newline
$r_{propagazione} = \frac{d}{s} = \frac{4800\times10^3 m }{3\times10^3 m/s}  = 0.016$ secondi.\newline
Sia il trasmission rate pari a 64 kbps, si calcoli il ritardo di trasmissione. \newline
$r_{trasmissione} = \frac{L}{R} = \frac{10^6 bit}{64\times10^3 bps}= 15.625$ secondi.\newline
Se il trasmission rate fosse invece di 1 Gbps? \newline
$r_{trasmissione} = \frac{L}{R} = \frac{10^6 bit}{10^9 bps} = 0.001$ secondi.

\subsection{Volume di un link}
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Link_Volume.png}
	\centering
\end{figure}
\theoremstyle{definition}
\begin{definition}
	Il volume di un link è il numero massimo di bit che il link può contenere.
\end{definition}
\centerline{\fbox{$Volume = bit rate\times ritardo$}}

\subsection{Esempio}
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Esempio_ritardi.png}
	\centering
\end{figure}
Si calcoli il ritardo end-to-end di un pacchetto su un percorso con due router. Sia trascurabile il ritardo di congestione e si suppongano uguali su tutti link il propagation delay, il transmission delay e il processing delay.\newline\newline
\textbf{Soluzione}:\newline Essendoci due router intermedi bisongna attraversare tre link, quindi:\newline
\centerline{$r_{totale} = 3\times r_{propagation} + 3\times r_{trasmission} + 3\times r_{processing}$}
\newpage
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Soluzione_ritardi.png}
	\centering
	\caption{Quello che succede in dettaglio nell'esempio precedente.}
\end{figure}

\section{Modelli Stratificati e Protocolli}
\textit{Cos'è un protocollo? Cos'è uno strato?}

\begin{figure}[!h]
	\includegraphics[scale=0.7]{Immagini/Postale.png}
	\centering
	\caption{Esempio di stratificazione. Si nota come i vari strati del modello interagiscono tra di loro, dal basso verso l'alto e viceversa, per consentire al sig. Rossi e al sig. Takamura di scambiarsi lettere.}
\end{figure}
\textbf{\underline{Vademecum per la lettura del seguente contenuto: N.B.}}:
\begin{enumerate}
	\item Gli strati comunicano \textit{(di solito)} \textbf{solo} con gli altri strati a loro adiacenti.
	\item Uno strato \textbf{fornisce} servizi allo strato superiore e \textbf{riceve} servizi da quello inferiore.
	\item La comunicazione tra strati adiacenti avviene attraverso un'\textbf{interfaccia}.
	\item Tra due entità diverse comunicano fra di loro solo gli strati dello \textbf{stesso livello} e secondo un \textbf{protocollo assegnato}, queste due entità sono dette \textbf{peer}.
\end{enumerate}
\newpage

\subsection{OSI: Open Systems Interconnection}
Le \textbf{prime} reti di calcolatori nacquero come \textbf{sistemi chiusi} in cui tutti i componenti dovevano essere dello stesso costruttore. Erano quindi tecnologie chiuse e \textbf{non interoperabili} l'una con l'altra a causa di drastiche differenze \textit{(e.g. differenza di linguaggio, \textbf{modelli di stratificazione diversi} e impossibilità per i programmi applicativi di riuscire ad operare in ambiente distribuito)}. Alla fine degli anni ‘60 esistevano: ARPANET, SNA (IBM), DNA (Digital).\newline
I \textbf{Sistemi Aperti} nascono dall'obbiettivo di alcune aziende di realizzare una rete di calcolatori in cui qualsiasi terminale potesse comunicare con un qualsiasi fornitore di servizi mediante qualsiasi rete.\newline\newline
Per realizzare un sistema aperto è necessario stabilire delle regole comuni: \textbf{gli standards}.
\theoremstyle{definition}
\begin{definition}
	Un sistema che implementa \textbf{protocolli aperti} è un \textbf{sistema aperto} (open system).
\end{definition}
\begin{definition}
	Un set di protocolli è \textbf{aperto} se:
	\begin{enumerate}
		\item I dettagli (\textbf{specifiche}) dei protocolli sono disponibili pubblicamente.
		\item I cambiamenti al set sono gestiti da un’organizzazione la cui
		      partecipazione è aperta al pubblico
	\end{enumerate}
\end{definition}

\subsubsection{Modello ISO/OSI}
L’International Organization for Standards (ISO) ha specificato
uno standard per l’interconnessione di sistemi aperti: l' \textbf{Open System Interconnection Reference Model} (OSI-RM) poi diventato standard internazionale nel 1983 (ISO 7498). \textbf{Si basa sul concetto di architettura a strati i cui criteri sono:}.
\begin{itemize}
	\item \textbf{Divisione delle funzionalità}: il protocollo di telecomunicazione è diviso in strati o layers, ognuno dei quali svolge un compito piccolo e indipendente dagli altri.\newline
	      Si cerca quindi di mantenere un minor numero di strati possibile e di far svolgere a ognuno di essi il minor numero di compiti possibile.
	\item \textbf{Comunicazione mediante interfacce}: i livelli comunicano mediante \textbf{chiamate standard}. Ogni livello è tenuto a rispondere alle \textbf{sole} chiamate che gli competono e che verranno
	      invocate dai due livelli ad esso adiacenti.
	\item \textbf{Information hiding}: le modalità con cui le funzioni competenti ad un livello
	      vengono svolte non è visibile dall'esterno che ne è così
	      svincolato.
\end{itemize}

\subsection{Protocollo}
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Protocollo.png}
	\centering
\end{figure}
I protocolli definiscono il \textbf{formato} e l’\textbf{ordine} dei
messaggi inviati e ricevuti tra entità della rete al livello n-esimo e
le \textbf{azioni} che vengono fatte per la loro \textbf{trasmissione} e
\textbf{ricezione}.
\theoremstyle{definition}
\begin{definition}
	Un \textbf{protocollo} è un insieme di regole che permettono a due entità uno scambio \textbf{efficace} ed \textbf{efficiente} delle informazioni. \textbf{Definisce} il \textbf{formato} e il
	\textbf{significato} dei frame (campi del messaggio), dei pacchetti o dei messaggi
	che vengono scambiati tra gli \textbf{strati paritari} di due
	entità diverse.
\end{definition}
Un protocollo specifica quindi:
\begin{itemize}
	\item La \textbf{sintassi} di un messaggio (e.g. i campi).
	\item La \textbf{semantica}.
	\item  \textbf{Le azioni da compiere }(e.g. per l'invio, alla ricezione, alla trasmissione etc...).
\end{itemize}
\theoremstyle{definition}
\begin{definition}
	Uno \textbf{strato} o livello è un modulo interamente definito attraverso i
	servizi, protocolli e le interfacce che lo caratterizzano.
\end{definition}
\theoremstyle{definition}
\begin{definition}
	Un' \textbf{interfaccia} è il set di regole governanti sintassi e semantica della comunicazione tra due \textbf{strati successivi} della \textbf{stessa entità}.
\end{definition}
\theoremstyle{definition}
\begin{definition}
	Un \textbf{servizio} è insieme di \textbf{primitive} (operazioni) che uno strato
	fornisce ad uno strato soprastante. (\textit{vedi sez. 3.4.1}).
\end{definition}
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Protocol_stack.png}
	\centering
	\caption{Esempio di stack protocollare.}
\end{figure}
\begin{figure}[!h]
	\includegraphics[scale=0.7]{Immagini/Osi_strati.png}
	\centering
	\caption{Gli strati di OSI.}
\end{figure}
\begin{figure}[!h]
	\includegraphics[scale=0.7]{Immagini/End_sys.png}
	\centering
	\caption{Esempio di collegamento tra end systems.}
\end{figure}
\newpage
\subsection{Incapsulamento dell'informazione}
All'interno della rete l'informazione ha origine \textbf{al livello
	applicativo} (\textit{livello 7 in figura}), discende quindi i vari livelli fino alla
\textbf{trasmissione}, che avviene mediante il \textbf{canale fisico}.
Da ogni livello attraversato viene aggiunta all'informazione una sezione informativa (o più di una) chiamata \textbf{header} che contiene informazioni pertinenti esclusivamente al livello stesso.
Per i dati ricevuti invece si segue il cammino inverso. Si tratta infatti di un \textbf{processo di incapsulamento \underline{reversibile}}.
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Incapsulamento.png}
	\centering
\end{figure}
\begin{itemize}
	\item \textbf{Header}: è qualificazione del pacchetto dati per questo livello.
	\item \textbf{DATA}: è il payload proveniente dal livello superiore.
	\item \textbf{Trailer}: è usato per rilevare e correggere gli errori.
\end{itemize}

\begin{figure}[!h]
	\includegraphics[scale=0.7]{Immagini/Incaps_2.png}
	\centering
	\caption{Il processo di incapsulamento. Da notare in particolare il payload.}
\end{figure}
\newpage

\section{Stack protocollare TCP/IP}
\textbf{TCP/IP} è una \textbf{famiglia di protocolli} attualmente
in uso su Internet.\newline Si tratta di una \textbf{gerarchia di
	protocolli} costituita da \textbf{moduli interagenti}, ciascuno dei
quali fornisce funzionalità specifiche.
Il termine \textbf{gerarchia} significa che ciascun protocollo di
\textbf{livello superiore} è supportato dai servizi \textbf{forniti} dai
protocolli di \textbf{livello inferiore}.
Definita in origine in termini di quattro livelli software
soprastanti a un livello hardware, \textbf{la pila TCP/IP} è \textbf{oggi}
intesa come \textbf{composta} \textbf{di cinque livelli}.
\begin{figure}[!h]
	\includegraphics[scale=0.6]{Immagini/TCP_IP.png}
	\centering
	\caption{Livelli dello stack protocollare TCP/IP, si notino le differenze tra il modello originario e il modello attuale.}
\end{figure}
\begin{itemize}
	\item Il \textbf{livello applicativo} supporta le applicazioni di rete.
	\item Il \textbf{livello di trasporto} supporta il trasferimento di dati da un host all'altro.
	\item Il \textbf{livello di rete} instrada i datagrammi dalla sorgente alla destinazione.
	\item Il \textbf{livello link} trasferisce dati tra elementi adiacenti della rete.
	\item  Al \textbf{livello fisico} troviamo i bit sul link.
\end{itemize}
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Incapsulamento_m.png}
	\centering
	\caption{Esemplificazione del processo di incapsulamento/decapsulamento dell'informazione.}
\end{figure}

\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Logfis.png}
	\centering
	\caption{I vari collegamenti logici di comunicazione, in \textbf{rosso} invece, \textbf{il collegamento fisico}. La modularità del sistema fa in modo che gli strati paritari dei due host abbiano l'\textbf{illusione} di comunicare direttamente tra di loro. Si ricorda che queste entità situate a livelli corrispondenti su macchine (host) diverse sono dette \textbf{peer}.}
\end{figure}

\subsection{Lo strato applicativo}
Dello \textbf{strato applicativo} fanno parte le \textbf{applicazioni di rete}. Le applicazioni di rete sono composte da \textbf{processi distribuiti} e \textbf{comunicanti}, ovvero programmi eseguiti dai dispositivi terminali (host o end system) di una rete. Nella comunicazione \textbf{a livello applicativo} fra due dispositivi terminali interconnessi, due o più processi sono in esecuzione su ciascuno degli host comunicanti e si scambiano messaggi.
Il protocollo dello strato applicativo definisce: (\textit{repetita iuvant})
\begin{itemize}
	\item I \textbf{tipi} di messaggi scambiati al livello
	      applicativo (e.g. richiesta e risposta).
	\item La \textbf{sintassi} e la \textbf{semantica} dei campi dei messaggi.
	\item Le \textbf{regole} di comunicazione \textbf{interprocessuale}.
\end{itemize}
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Application_layer.png}
	\centering
	\caption{Esempio di comunicazione tra applicazioni di rete. Ancora una volta è bene ricordare che il protocollo crea l'\textit{illusione} che i processi siano in comunicazione diretta.}
\end{figure}
Presentiamo ora i \textbf{paradigmi di comunicazione} dello strato applicativo:
\begin{itemize}
	\item \textbf{Client-Server}: prevede un numero \textit{limitato} di processi \textbf{server} che
	      offrono servizi e sono \textbf{sempre} in esecuzione in attesa di ricevere richieste dai client. Un \textbf{client} è un programma che richiede un servizio. Tipicamente il client inizia il contatto con il server \textbf{inviando una richiesta} e il server risponde \textbf{offrendo il servizio} richiesto.
	\item \textbf{Peer-to-Peer}: comunicazione tra \textbf{peer} \textit{(pari)} che possono sia \textbf{offrire} servizi che \textbf{inviare} richieste.
	\item  \textbf{Misto}.
\end{itemize}
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Client_server.png}
	\centering
	\caption{Esempio di paradigma client-server.}
\end{figure}
\newpage
Abbiamo, seppur assai brevemente, esaminato la comunicazione a livello applicativo tra macchine diverse. Scendiamo ora più nel dettaglio iniziando a tracciare il percorso \textbf{reale} dei dati dallo \textbf{strato applicativo} allo \textbf{strato di trasporto}. Partiamo dalla seguente definizione:

\theoremstyle{definition}
\begin{definition}
	\textbf{API}: acronimo di Application Programming Interface, è un insieme di \textbf{procedure} e \textbf{regole} che un programmatore deve seguire per accedere a delle risorse. Facilita molto la programmazione del software client-side.
\end{definition}
L' \textbf{API} che funge da \textbf{interfaccia} tra gli \textbf{strati di applicazione} \textbf{e} di \textbf{trasporto} è chiamata \textbf{socket} ed è usata dai processi dello strato applicativo per inviare e ricevere dati dallo strato di trasporto. Si tratta, ancora una volta, di una connessione \textbf{logica} poichè in realtà l'invio e la ricezione dei dati sono, nel \textbf{concreto}, responsabilità del sistema operativo e del protocollo TCP/IP.\newline
Riportiamo un estratto dell'\textbf{API} di \textbf{TCP:}\newline\newline
\texttt{connection TCPopen(IPaddress, int) //to open a conn.}\newline
\texttt{void TCPsend(connection, data) //to send data}\newline
\texttt{data TCPreceive(connection) //to receive data}\newline
\texttt{void TCPclose(connection) //to close a conn.}

\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Socket.png}
	\centering
	\caption{In figura due processi che comunicano tramite socket. Il processo è controllato dallo sviluppatore dell'applicazione, tutto ciò che è presente sotto la socket è controllato dal sistema operativo.}
\end{figure}
Sorge ora spontanea una domanda: \textbf{se ci fossero più processi su ogni host}?\newline
Servirebbe un modo per \textbf{identificarli}... ci viene in aiuto il \textbf{socket address}.
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Socket_addr.png}
	\centering
	\caption{Il socket address identifica sia il \textbf{processo} con il numero di porta che l'\textbf{host} con l'indirizzo IP, a ogni porta corrisponde un processo.}
\end{figure}
\newpage
\textbf{\underline{Riassumendo}}: dello strato applicativo fanno parte le \textbf{applicazioni di rete}, composte da \textbf{processi distribuiti} su macchine diverse che comunicano tra di loro mediante il protocollo proprio dello strato applicativo. Sebbene il protocollo fornisca alle applicazioni l'illusione di comunicare direttamente, la comunicazione è in realtà garantita da tutto lo stack protocollare sottostante. In particolare, lo strato applicativo dipende dai servizi offerti dallo \textbf{strato di trasporto} che gli è immediatamente sottostante. I due strati comunicano tramite una \textbf{API} che si chiama \textbf{socket}.\newline\newline
A seconda del \textbf{servizio di trasporto richiesto} dall'applicazione è possibile che si trovino in uso \textbf{protocolli di trasporto diversi} tra i quali: \textbf{TCP} e \textbf{UDP}. \textit{(vedi sez. 2.2)}
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Tcp_udp.png}
	\centering
	\caption{In figura le caratteristiche di alcune delle principali applicazioni di rete. Non tutte le applicazioni sono uguali. Tipicamente la telefonia di internet usa il protocollo UDP.}
\end{figure}
\subsubsection{Web}
Il \textbf{web} è formato da risorse indirizzate da \textbf{URL}, acronimo di \textbf{uniform resource locator}. Generalmente queste risorse sono \textbf{pagine web}, formate da altri oggetti referenziati \textit{(e.g. altre pagine web, immagini ecc...)}. Lo \textbf{user agent} o \textbf{client} per il web è chiamato \textbf{browser} ed il \textbf{server} è chiamato \textbf{web server}.
\theoremstyle{definition}
\begin{definition}
	Una \textbf{URI} o Uniform Resource Identifier è una stringa compatta di caratteri che identifica una risorsa fisica o astratta.
\end{definition}
Le \textbf{URL} sono un \textbf{sottoinsieme} delle URI e identificano le risorse tramite la loro posizione all'interno della rete. Le \textbf{URN} acronimo di \textbf{uniform resource name} sono un altro sottoinsieme delle URI la cui funzione è di rimanere \textbf{globalmente uniche} e \textbf{persistenti} anche quando le risorse da loro puntate cessano di esistere o non sono più disponibili.
La \textbf{sintassi} delle URI è organizzata \textbf{gerarchicamente} e i componenti sono disposti in ordine di importanza da sinistra verso destra.
\begin{figure}[!h]
	\includegraphics[scale=0.4]{Immagini/URIvsURL.png}
	\centering
	\caption{URN e URL non sono altro che specializzazioni delle URI.}
\end{figure}
\newpage
Le \textbf{sintassi} della URI:\newline\newline
\centerline{\LARGE$<scheme>://<authority><path>?<\textcolor{green}{query}>$}\newline\newline
\textcolor{red}{http}://\textcolor{blue}{maps.google.it}/\textcolor{purple}{maps}/\textcolor{purple}{place}?\textcolor{green}{q=largo+bruno+pontecorvo+pisa
	\&hl=it}
\begin{itemize}
	\item \textcolor{red}{\textbf{scheme}}: è \textbf{obbligatorio}, definisce lo \textbf{spazio dei nomi} della risorsa.
	\item \textcolor{blue}{\textbf{authority}}: indica il \textbf{nome di dominio} di un host \textit{(reg\_name)} o il suo \textbf{indirizzo IP} in notazione decimale puntata. Tipicamente identifica un computer sulla rete.
	\item \textcolor{purple}{\textbf{path}}: contiene \textbf{dati} specifici per l’authority (o per lo scheme) e \textbf{identifica} la risorsa \textbf{nel contesto} di quel namespace e di quell'authority.
\end{itemize}
Le URI possono essere \textbf{assolute} o \textbf{relative}, una \textbf{URI assoluta} identifica una risorsa \textbf{indipendentemente} dal contesto in cui è usata. Una \textbf{URI relativa} identifica una risorsa in relazione ad un'altra URL, \textbf{è priva di schema e di authority}, non viaggia sulla rete ed è interpretata dal browser in relazione al documento di partenza.\newline \textit{(e.g. http://www.w3.org/pub/WWW/TheProject.html oppure\newline /pub/WWW/TheProject.html \underline{sotto l'host}: www.w3.org)}.
\subsubsection{HTTP Protocol}
Il protocollo \textbf{HTTP} è un protocollo di tipo \textbf{request}/\textbf{response}: il client inizia la connessione inviando un messaggio di \textbf{request} al server che a sua volta invia una \textbf{response}. Si tratta di un \textbf{protocollo generico}, poichè non dipende dal formato delle risorse, e \textbf{stateless} poichè \textbf{le coppie richiesta/risposta sono indipendenti l'una dall'altra}. In \textbf{HTTP 1.0} dopo la prima coppia di richiesta/risposta la connessione viene \textbf{terminata} mentre in \textbf{HTTP 1.1} si \textbf{procede} con un’altra coppia. \newline
Lo \textbf{schema http} è usato per accedere alle risorse attraverso il protocollo HTTP. \newpage
Si riporta di seguito la \textbf{sintassi} per le URL http:\newline\newline
\centerline{\LARGE$http: // <host> [ : <port> ] [ <path> ]$}
\begin{itemize}
	\item \textbf{host}: è un \textbf{host domain di Internet} valido oppure un indirizzo IP in forma decimale puntata.
	\item \textbf{port}: \textbf{è un intero}, se  la porta è vuota o non è indicata si usa automaticamente la porta 80.
	\item \textbf{path}: specifica la \textbf{request URI} \textit{(vedi seguito)}.
\end{itemize}
\textbf{\underline{N.B.} Il protocollo HTTP utilizza il protocollo TCP tramite la sua API.}\newline\newline
//esempio client\newline
\texttt{c = TCPopen("131.115.7.24", 80);}\newline
\texttt{TCPsend(c,"GET /index.html");}\newline
\texttt{d = TCPreceive(c);}\newline\newline
\texttt{//esempio server}\newline
\texttt{p = TCPbind(80); //where to wait for connections}\newline
\texttt{d = TCPaccept(p); //waiting for connections}\newline
\texttt{r = TCPreceive(d);}\newline
\texttt{...}\newline
\texttt{TCPsend(d,pag);}\newline
\texttt{TCPclose(d);}\newline
\theoremstyle{definition}
\begin{definition}
	Una \textbf{connessione http} è  un circuito logico di livello di trasporto stabilito tra due programmi applicativi per comunicare tra loro.
\end{definition}
Una \textbf{connessione} può essere:
\begin{itemize}
	\item \textbf{Non persistente}\textit{(http1.0: RFC 1945)}: si parla di connessione non persistente quando \textbf{per ogni richiesta} del \textbf{client} viene instaurata \textbf{una nuova connessione} con il \textbf{server}. Ciò aumenta il \textbf{carico} su quest ultimo e potrebbero verificarsi fenomeni di \textbf{congestione}. \textit{Infatti per visualizzare le n immagini di un sito il client invia di seguito n richieste al server.}
	\item \textbf{Persistente}\textit{(http1.1: RFC 2616)}: la connessione è appunto \textbf{persistente}. Nello \textbf{standard} è specificato un meccanismo che consente al server di \textbf{chiudere} la connessione TCP su richiesta del client. \textit{(CONNECTION = CLOSE, in GENERAL HEADER, vedi seguito.)}\newline \textbf{\underline{N.B.}} Una volta che la chiusura della connessione è stata segnalata, il client \textbf{non deve} inviare altre richieste.
\end{itemize}
\newpage
\textbf{Esempio:}\newline
Supponiamo che l’utente digiti la seguente URL:\newline\newline \centerline{\textbf{www.someSchool.edu/someDepartment/home.index}}\newline\newline
Con \textbf{una connessione non persistente}, in ordine temporale succedono le seguenti cose:
\begin{enumerate}
	\item Il \textbf{client http}  invia una richiesta di connessione
	      \textbf{TCP} verso il server http al \textbf{www.someSchool.edu} \textit{(La porta 80 è usata di default per il server http.)}
	\item Il \textbf{server http} dell’host	\textbf{www.someSchool.edu}, che aspetta le richieste di connessione \textbf{TCP} alla \textbf{porta 80}, \textbf{accetta} \textbf{la richiesta di connessione}  e notifica il client.
	\item Il \textbf{client http} invia quindi un \textbf{messaggio di richiesta}, contenente la URL.
	\item Il \textbf{server http} riceve il messaggio di richiesta, compila un \textbf{messaggio di risposta} con l’oggetto richiesto indicato dalla URL: \textbf{someDepartment/home.index}, invia il messaggio e in seguito \textbf{chiude} la connessione.
	\item Il \textbf{client http}  riceve il messaggio di risposta che contiene il file html e lo visualizza.
\end{enumerate}
\textit{Si ricorda che la ricezione e la trasmissione di tutti i messaggi elencati poco sopra avviene tramite socket.}\newline
Supponiamo ora che la URL contenga dei riferimenti a 10 immagini, in tal caso per ogni riferimento si devono ripetere tutti i passaggi definiti sopra. Salta immediatamente all'occhio la \textbf{scarsa efficienza} della procedura.\newline\newline
Con \textbf{una connessione persistente} invece il server lascerebbe aperta la connessione TCP dopo aver spedito la prima risposta e vi riceverebbe quindi le richieste successive. La connessione verrebbe chiusa dal server quando specificato nell’header di un messaggio  \textbf{inviatogli dal client}, oppure alla mancata ricezione di richieste per un certo intervallo di tempo \textit{(time out)}.\newline\newline
Un ulteriore miglioramento delle prestazioni, si otterrebbe con una tecnica di \textbf{pipelining}, consistente nell’invio da parte del client di molteplici richieste senza aspettarne la ricezione da parte del server.\newline
Il \textbf{server} \textbf{deve} tuttavia inviare le risposte nello stesso ordine in cui sono state ricevute le richieste e il \textbf{client} \textbf{non} può inviare \textbf{in pipeline} richieste che usano metodi HTTP \textbf{non idempotenti}. Ma cos'è un \textbf{metodo idempotente}?
\theoremstyle{definition}
\begin{definition}
	Un \textbf{metodo idempotente} è un metodo tale che il suo effetto collaterale sulla risorsa è lo \textbf{stesso} per N o 1 richieste identiche che ne fanno uso. \textit{(e.g. GET, HEAD, PUT, DELETE, OPTIONS, TRACE)}
\end{definition}
\theoremstyle{definition}
\begin{definition}
	Un \textbf{metodo safe} è un metodo che non produce effetti collaterali sulle risorse. \textit{(e.g. non le modificano: GET, HEAD, OPTIONS, TRACE...)}
\end{definition}
\begin{figure}[!h]
	\includegraphics[scale=0.4]{Immagini/Http_vs.png}
	\centering
	\caption{In figura sono rappresentate le differenze viste prima.}
\end{figure}
\textit{Come sono strutturati i messaggi HTTP?}\newline\newline
Riportiamo di seguito la \textbf{struttura} di un generico messaggio http:\newline
\texttt{Request = Request-Line} \textit{o} \texttt{Response = Status-Line} \textit{per i messaggi di risposta.}\newline
\texttt{*( general-header}\newline
\texttt{| request-header} \textit{o} \texttt{response-header}\newline
\texttt{| entity-header )}\newline
\texttt{CRLF}\newline
\texttt{[ message-body ]}\newline
La prima riga o \textbf{start line} distingue i messaggi di request dai messaggi di response.
\begin{figure}[!h]
	\includegraphics[scale=0.25]{Immagini/Http_req.png}
	\centering
	\caption{In figura un messaggio di richiesta.}
\end{figure}
\begin{figure}[!h]
	\includegraphics[scale=0.25]{Immagini/Http_res.png}
	\centering
	\caption{In figura un messaggio di risposta.}
\end{figure}
\newpage
\begin{figure}[!h]
	\includegraphics[scale=0.3]{Immagini/Req_line.png}
	\centering
	\caption{La struttura della \textbf{request line}. Il campo \textbf{method} è case sensitive ed indica l'operazioe da eseguire sulla risorsa identificata dalla URI. Il metodo \textbf{POST} serve per inviare dal client al server le
		informazioni inserite nel body del messaggio, \textbf{PUT} è usato dal client per chiedere al server di creare o modificare una risorsa, \textbf{DELETE} per cancellarla.}
\end{figure}
\begin{figure}[!h]
	\includegraphics[scale=0.4]{Immagini/Stat_line.png}
	\centering
	\caption{La \textbf{status-Line} è la prima riga del messaggio di risposta. Lo \textbf{status code} è un numero di 3 cifre, indica il risultato del tentativo di soddisfare la richiesta del client. La \textbf{reason-phrase} dà una breve descrizione testuale dello status-code. Lo status-code è rivolto alla macchina mentre la reason-phrase all'utente umano.}
\end{figure}
Gli \textbf{header} sono insiemi di coppie \textbf{nome} : \textbf{valore} che specificano
alcuni parametri del messaggio trasmesso o ricevuto.
\begin{itemize}
	\item \textbf{General Headers}: sono relativi alla \textbf{trasmissione} e si applicano a \textbf{tutto il messaggio}. \textit{(e.g. \textbf{Date, Connection:} usato dal mittente per specificare delle opzioni desiderate per la connessione, ad esempio \underline{close}. \textbf{Transfer-encoding}: specifica se e quali trasformazioni sono state applicate al corpo del messaggio ad esempio gzip, chunked ecc. \textbf{Cache control}: indica quale tipologia di cache può memorizzare il messaggio, può essere \textbf{public}, \textbf{private} o \textbf{no-cache}.)}
	\item \textbf{Entity Headers}: sono \textbf{metadati} relativi all'\textbf{entità trasmessa}. Ogni entity è costituita da un \textbf{entity body} e da una
	      serie di \textbf{entity headers} che ne definiscono contenuto e
	      proprietà. \textit{(e.g. Content Lenght)}
	\item \textbf{Request Headers}: sono relativi alla \textbf{richiesta}. Supportano il \textbf{content negotiation}, il processo tramite cui il server sceglie la forma "giusta" del contenuto richiesto dal client. \textit{(Specificano da chi è fatta la richiesta, a chi viene fatta, che tipo di risposte il client è in grado di accettare, l'autorizzazione, ecc.)}
	\item \textbf{Response Headers}: sono relativi al \textbf{messaggio di risposta}.
\end{itemize}
\newpage
\begin{figure}[!h]
	\includegraphics[scale=0.3]{Immagini/General_h.png}
	\centering
	\caption{L'elenco dei general headers.}
\end{figure}
\begin{figure}[!h]
	\includegraphics[scale=0.3]{Immagini/Req_h.png}
	\centering
	\caption{L'elenco dei request headers. \textbf{Accept} specifica quali tipi di media sono accettati in risposta dal client, \textbf{Accept-Charset}, quali caratteri e \textbf{Accept-Encoding} quali formati.}
\end{figure}
\begin{figure}[!h]
	\includegraphics[scale=0.3]{Immagini/Stat_code.png}
	\centering
	\caption{In figura l'elenco degli status-codes e il loro significato.}
\end{figure}
\begin{figure}[!h]
	\includegraphics[scale=0.3]{Immagini/Resp_h.png}
	\centering
	\caption{I campi del \textbf{response-header} consentono al server di inviare informazioni aggiuntive che non possono essere poste nella status-line. Ad esempio: \textbf{Age}: indica quanto tempo è trascorso, in secondi, tra l'invio della risposta da parte del mittente e la generazione della stessa all'origine. \textbf{Location} é usato per reindirizzare il client verso un altra URI per completare la sua richiesta o per fornire una nuova risorsa. Il campo \textbf{Server} contiene informazioni sul software usato dal server di origine per portare a compimento la richiesta del client.}
\end{figure}
\newpage
Fin'ora abbiamo mostrato come il client accede alle risorse del web inviando richieste al server. Cosa succederebbe se, ad esempio, un client richiedesse continuamente la \textbf{stessa} risorsa? Potremmo evitare di inoltrare richieste tutte uguali al server?\newline
\textbf{Sì}, ci viene in aiuto il \textbf{web caching}. L'obbiettivo del web caching è di soddisfare le richieste del client \textbf{senza} contattare il server. Funziona memorizzando \textbf{copie temporanee} di risorse web, servendole poi al client così da \textbf{ridurre} l’uso di \textbf{banda}, limitare il \textbf{workload} sul server e di conseguenza \textbf{diminuire tempo di risposta} verso gli altri clients.\newline
Consideriamo due modelli possibili di web caching:
\begin{itemize}
	\item \textbf{User Agent Cache}: lo \textbf{user agent} (il browser) mantiene una \textbf{copia} delle risorse visitate dall’utente.
	\item \textbf{Proxy Cache}: il \textbf{proxy intercetta il traffico} e mette in cache le risposte. Successive richieste alla stessa URI possono essere servite direttamente dal proxy senza inoltrare la richiesta al server. Sta poi all' utente configurare il browser per consentire gli accessi Web via proxy.
\end{itemize}

\textit{Cos'è un proxy?}
\theoremstyle{definition}
\begin{definition}
	Un \textbf{proxy} è un \textbf{programma intermediario} che agisce sia da \textbf{server} che da \textbf{client}, \textbf{inviando} e \textbf{servendo} \textbf{richieste} per altri clients. Le richieste sono gestite internamente oppure sono girate a server terzi.
\end{definition}
Resta ora da chiarire come è possibile che, sebbene abbiamo definito il protocollo HTTP come \textbf{stateless}, alcuni siti, \textit{riconoscano} gli utenti.\newline
Sebbene infatti il protocollo HTTP sia a tutti gli effetti stateless, le applicazioni web \textbf{non} lo sono. Come fare quindi a conciliare queste due realtà?\newline\newline
\textit{Con i coockies!}
\begin{definition}
	I \textbf{coockies} sono stringhe di testo contenenti informazioni relative all'utente.
\end{definition}
I \textbf{coockies} funzionano nel seguente modo:
\begin{enumerate}
	\item Un client invia al server una richiesta HTTP.
	\item Il server invia al client la risposta HTTP e in più una linea \textbf{set-cookie: 1678453}. \textit{(esempio fittizio)}
	\item Il client \textbf{memorizza} il cookie in un file e lo associa al server.
	      Lo aggiungerà con la seguente linea: \textbf{cookie: 1678453} a tutte le sue successive richieste.
	\item Alla successiva richiesta da parte del client, il server \textbf{risalirà} tramite il cookie alle informazioni ad esso \textbf{associate}.
\end{enumerate}
\newpage

\subsubsection{TELNET}
\textbf{TELNET}, acronimo per \textbf{TE}rmina\textbf{L} \textbf{NET}work, è un \textbf{protocollo} \textbf{client-server} che fornisce una comunicazione \textbf{interattiva ed orientata al testo} tra due macchine, è basato sul trasporto \textbf{connection-oriented} ed usa il protocollo \textbf{TCP}.
Consente all'utente di effettuare una sessione di \textbf{login} in una macchina remota e quindi di utilizzarne il terminale. L'utente che si autentica tramite login remoto ha accesso infatti a tutti i \textbf{comandi} e ai \textbf{programmi} disponibili su di essa. \textbf{I comandi vengono eseguiti come se l'utente li digitasse dalla tastiera stessa della macchina.} \textit{Per estensione,} \texttt{\textbf{telnet}} \textit{è anche il nome di un programma usato per avviare una sessione TELNET verso un host remoto.}
\textbf{TELNET} infatti include due programmi: un programma \textbf{TELNET client} e un programma \textbf{TELNET server}. \textbf{TELNET client} (\texttt{\textbf{telnet}}) interagisce con l'utente sulla macchina locale e scambia messaggi con \textbf{TELNET server}. Riportiamo di seguito una semplificazione del funzionamento:
\begin{enumerate}
	\item L'utente, dalla \textbf{propria} macchina \textbf{locale} (\textbf{\textbf{TELNET client}}), stabilisce una connessione \textbf{TCP}, persistente per tutta la durata della sessione, con una \textbf{macchina remota (\textbf{TELNET server})} alla \textbf{porta 23} e vi si \textbf{autentifica}.
	\item  Tutte le \textbf{battute} dei \textbf{tasti} della macchina locale vengono \textbf{trasmesse} dal client
	      alla \textbf{macchina remota}.
	\item La \textbf{macchina remota} accetta la connessione TCP e il \textbf{TELNET server} trasmette i dati al sistema operativo locale.
	\item L'\textbf{output} della \textbf{macchina remota} viene quindi \textbf{ricevuto} e \textbf{trasmesso} sul terminale dell'utente.
\end{enumerate}
\begin{figure}[!h]
	\includegraphics[scale=0.8]{Immagini/TELNET.png}
	\centering
	\caption{In figura il funzionamento di TELNET.}
\end{figure}
\underline{N.B. TELNET è un protocollo STATEFUL.}
\newpage
\textit{Problema: come operare con sistemi operativi diversi?}\newline\newline
I terminali infatti non sono tutti uguali, possono differire gli uni dagli altri per il \textbf{set} e la \textbf{codifica} dei caratteri, per la \textbf{lunghezza} della \textbf{linea} e della \textbf{pagina} e per i \textbf{tasti funzione} individuati da diverse sequenze di caratteri. \newline\newline
Una \textbf{soluzione} è stata trovata mediante la definizione di un \textbf{Network Virtual  Terminal (NVT) che definisce un \textbf{set di caratteri universali}}.
L’NVT è quindi un dispositivo “immaginario” che fornisce una
rappresentazione astratta di un terminale. Gli host, sia client
che server, \textbf{traducono} le loro caratteristiche \textbf{locali} \textbf{tramite il set universale} così da apparire \textbf{in rete} come un NVT e assumono che l’host remoto sia anch'esso un NVT. Questa operazione di traduzione è ovviamente \textbf{reversibile}.
\begin{figure}[!h]
	\includegraphics[scale=0.6]{Immagini/NVT.png}
	\centering
\end{figure}
\newline
Il funzionamento di TELNET, con l'aggiunta della trasformazioni intermedie sopra descritte diventa:
\begin{enumerate}
	\item ...
	\item  Tutte le \textbf{battute} dei \textbf{tasti} della macchina locale vengono \textbf{trasformate in NVT e successivamente} \textbf{trasmesse dal TELNET client}
	      alla \textbf{macchina remota}.
	\item La \textbf{macchina remota} accetta la connessione TCP, il \textbf{TELNET server} \textbf{traduce} da NVT allo standard del sistema operativo remoto e infine gli trasmette i dati ricevuti.
	\item ...
\end{enumerate}
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/NVT2.png}
	\centering
\end{figure}
\underline{\textit{N.B. NVT invia i caratteri di controllo prioritariamente con TCP URGENT.}}
\newpage
Concludiamo con qualche tecnicismo: \newline\newline
I terminali NVT si scambiano dati in formato \textbf{7-bit US-ASCII} e adottano inoltre un approccio \textbf{in-band signaling}, ovvero dati e comandi viaggiano sullo \textbf{stesso canale}. Per distinguere i due tipi di informazione si usa la seguente convenzione: ogni carattere è inviato come un \textbf{ottetto di bit} con \textbf{il primo bit settato a zero}. I caratteri, in notazione decimale, vanno dal numero 0 al 127. I comandi invece sono identificati tramite  ottetti speciali di 1, in n. d. vanno dal numero 240 al numero 254, per distinguerli dai dati sono sempre preceduti da un carattere speciale: \textbf{IAC o Interpret As Command} identificato, sempre in n. d., dal numero 255. Essenzialmente quindi si usa un canale di 8 bit per scambiare dati di tipo 7 bit ASCII. I messaggi scambiati durante la fase iniziale della comunicazione, ovvero prima del login, sono \textbf{messaggi di controllo} e costituiscono la \textbf{Telnet Option Negotiation}, in sostanza sono usati per scambiare \textbf{informazioni} sulle \textbf{caratteristiche} degli \textbf{host}.
\begin{table}[h!]
	\begin{center}
		\label{tab:table1}
		\begin{tabular}{l|c|r}
			\textbf{Comando} & \textbf{Codifica decimale} & \textbf{Significato} \\
			\hline
			IAC              & 255                        & Interpret as command \\
			EL               & 248                        & Erase line           \\
			EC               & 247                        & Erase character      \\
			IP               & 244                        & Interrupt process    \\
			EOR              & 239                        & End of record        \\
		\end{tabular}
	\end{center}
\end{table}\newline
\textit{Ma quindi NVT conviene?}\newline\newline
Rispondiamo alla domanda mostrando dei semplici calcoli:\newline\newline
Supponiamo che N sia il numero di sistemi distinti che si vogliono far
interoperare:
\begin{itemize}
	\item \textbf{Senza} l'uso di NVT, si necessita la scrittura di \textbf{N-1} client per ogni sistema (N-1 TELNET-clients che traducano negli N-1 standards dei sistemi), e 1 TELNET-server per ogni sistema: \newline
	      In totale si avranno $N\times(N-1) + N$ applicativi.
	\item \textbf{Usando} NVT, bisogna scrivere 1 TELNET-server per ogni sistema e N TELNET-client (1 per ogni sistema che traduca dallo standard di sistema allo standard di NVT): \newline Avremo quindi $N + N = 2N$ applicativi.
\end{itemize}
Quindi per $N > 2$ \textbf{conviene} usare NVT!
\newpage
\subsubsection{SSH}
TELNET non possiede \textbf{alcuna} misura di sicurezza poichè è stato progettato per l'uso su \textbf{reti private}, trasmette tutto in chiaro, anche le \textbf{password}! Con l'avvento delle reti pubbliche però si è reso necessario prendere delle contromisure. \newline
\textbf{SSH} o \textbf{S}ecure \textbf{SH}ell è un'applicazione nata per sostituire TELNET.
\begin{figure}[!h]
	\includegraphics[scale=0.7]{Immagini/SSH.png}
	\centering
	\caption{Le componenti di SSH}
\end{figure}\newline
Il \textbf{protocollo} di livello applicazione \textbf{SSH} è composto da \textbf{tre} diverse componenti: \textbf{SSH-TRANS, SSH-AUTH e SSH-CON}. La componente \textbf{SSH-TRANS} o \textbf{SSH-Transport Layer Protocol} costruisce un canale di comunicazione sicuro, tramite tecniche crittografiche, sfruttando la connessione offerta da TCP. Il \textbf{protocollo TCP} trasmette tutte le informazioni in chiaro, \textbf{non} è quindi in grado \textbf{da solo} di garantire \textbf{privacy} e \textbf{confidenza}. \textit{SSH-TRANS è anche in grado di riconoscere se il server a cui ci stiamo connettendo è quello autentico o meno.} La componente \textbf{SSH-AUTH} si occupa di autenticare il client. \textit{Sono disponibili altre tecniche di autenticazione oltre alla classica con username e password tra le quali l'accesso basato su coppie di chiavi crittografiche.} Infine la componente \textbf{SSH-CONN} sfruttando i servizi offerti dalle altre due componenti offre i servizi di \textbf{terminale}, \textbf{trasferimento file}, \textbf{creazione di tunnel} ecc...\newline \textbf{SSH offre} quindi \textbf{molti più servizi di TELNET}.\newline\newline
\textbf{TCP Port Forwarding:}\newline\newline
\textbf{TCP Port Forwarding} è un meccanismo che permette di \textbf{creare} un \textbf{canale di comunicazione sicuro} attraverso il quale \textbf{veicolare} \textbf{qualsiasi} tipo di \textbf{connessione TCP}. Opera creando un canale di comunicazione \textbf{cifrato} tra la \textbf{porta} all’\textbf{indirizzo remoto} a cui ci si vuole collegare e una \textbf{porta locale} libera.  le applicazioni punteranno il collegamento alla porta locale e la connessione verrà inoltrata automaticamente all’host remoto
tramite un canale sicuro. \newline Segue una spiegazione delle differenze tra \textbf{local port forwarding} e \textbf{remote port forwarding}.
\newpage
\begin{itemize}
	\item \textbf{Local}: \texttt{ssh -L} specifica che il traffico sulla porta indicata della macchina locale deve essere reindirizzato verso la porta indicata della macchina remota. \newline
	      e.g. \texttt{ssh -L sourcePort:forwardToHost:onPort connectToHost} significa: connettiti via ssh a \textbf{connectToHost}, e inoltra tutti i tentativi di connessione che arrivano alla porta locale \textbf{sourcePort} verso la porta \textbf{onPort} della macchina chiamata \textbf{forwardToHost}, che si raggiunge tramite la macchina chiamata a sua volta \textbf{connectToHost}.
	      \begin{figure}[!h]
		      \includegraphics[scale=0.8]{Immagini/Local_ssh.png}
		      \centering
	      \end{figure}
	      \newpage
	\item \textbf{Remote}: \texttt{ssh -R} specifica che il traffico sulla porta indicata della macchina remota deve essere reindirizzato verso la porta indicata della macchina locale.\newline
	      e.g. \texttt{ssh -R sourcePort:forwardToHost:onPort connectToHost} significa: connettiti via ssh a \textbf{connectToHost}, e inoltra tutti i tentativi di connessione che arrivanao alla porta remota \textbf{sourcePort} verso la porta \textbf{onPort} della macchina \textbf{forwardToHost}, che si raggiunge tramite la tua macchina locale.
	      \begin{figure}[!h]
		      \includegraphics[scale=0.9]{Immagini/Remote_ssh.png}
		      \centering
	      \end{figure}
\end{itemize}
\underline{N.B. SSH è un protocollo STATEFUL.}
\newpage
\subsubsection{FTP}
\textbf{FTP} acronimo per \textbf{F}ile \textbf{T}ransfer \textbf{P}rotocol, è un \textbf{protocollo} per il \textbf{trasferimento} di \textbf{dati} tra due host di una rete, è lo \textbf{standard} per il \textbf{trasferimento} di file \textbf{offerto da TCP/IP}. Adotta il modello \textbf{client-server}: il \textbf{client} richiede il trasferimento di un file che può consistere sia nell'\textbf{acquisizione} di una copia locale modificabile sia nell'eventuale \textbf{trasferimento} della copia modificata sull'host remoto (\textbf{server}).
\begin{figure}[!h]
	\includegraphics[scale=0.4]{Immagini/FTP.png}
	\centering
\end{figure}\newline
Il \textbf{client} ha \textbf{tre} componenti: \textbf{interfaccia utente}, \textbf{processo di controllo} e \textbf{processo di trasferimento dati} mentre il \textbf{server} remoto ne ha solo \textbf{due}: \textbf{processo di controllo} e \textbf{processo di trasferimento dati}. La \textbf{separazione} del trasferimento dei dati da quello dei comandi rende il protocollo FTP \textbf{efficiente}. Infatti la \textbf{connessione di controllo} usa \textbf{regole semplici} così da ridurre lo scambio delle informazioni a \textbf{una riga di comando} e \textbf{una di risposta per ogni interazione}. Mentre la \textbf{connessione dati usa regole più complicate} a causa della varietà delle informazioni che vi transitano.
\textbf{FTP} offre funzionalità \textbf{aggiuntive} oltre al semplice trasferimento di dati, infatti \textbf{mette a disposizione}:
\begin{itemize}
	\item \textbf{Accesso interattivo}: l’utente può \textbf{navigare}, \textbf{cambiare} e \textbf{modificare} l’albero di directory nel file system dell'host remoto.
	\item \textbf{Specificazione del formato dei dati da trasferire} (e.g. file di testo o file binari)
	\item \textbf{Autenticazione}: il client può \textbf{autenticarsi} con username e password.
\end{itemize}
Poco sopra abbiamo accennato al fatto che \textbf{FTP} prevede l'instaurazione di \textbf{due tipi di connessione tra il client e il server} ovvero:
\begin{enumerate}
	\item \textbf{Control connection}: prevede uno scambio di comandi e risposte
	      tra client e server. Segue il protocollo TELNET e \textbf{rimane aperta per l'intera durata della sessione interattiva}. Si usa la \textbf{porta 21} del \textbf{server} e la codifica standard \textbf{NVT ASCII}.
	\item \textbf{Data connection}: prevede il trasferimento di dati mediante procedure e la \textbf{specifica dei tipi}. I dati trasferiti possono essere parte di un file, un file o un set di file. \textbf{Viene aperta e chiusa per ogni singolo scambio}. Per lo scambio di dati il \textbf{server} usa la \textbf{porta 20}.
\end{enumerate}
\newpage
La \textbf{Data Connection} \textbf{non segue il protocollo TELNET} e la sua apertura avviene secondo uno schema completamente diverso, ovvero:
\begin{enumerate}
	\item Il \textbf{client}, non il server, effettua un'\textbf{apertura} \textbf{passiva} usando una \textbf{porta effimera} e resta in attesa di connessione, viene fatto dal client poichè è tale processo che invierà i comandi, tramite la connessione di controllo, per il trasferimento dei file.
	\item Il client \textbf{invia} questo \textbf{numero} di \textbf{porta} al \textbf{server} per mezzo del comando PORT.
	\item Il \textbf{server}, ricevuto il numero di porta, \textbf{effettua} un'\textbf{apertura} \textbf{attiva}, ovvero apre la connessione, usando la propria \textbf{porta} nota \textbf{20} e quella effimera offerta dal client.
\end{enumerate}
Per effettuare il trasferimento dei file inoltre, il client deve \textbf{definire} il \textbf{tipo}
di file, la \textbf{struttura dati} e la \textbf{modalità di trasmissione} al fine di
risolvere i problemi di eterogeneità tra client e server, va infatti ricordato che programma client e programma server sono su macchine \textbf{diverse}. Questo scambio di informazioni avviene mediante la \textbf{connessione di controllo}.\newline\newline
FTP è quindi un protocollo \textbf{STATEFUL} poichè il \textbf{server deve tener traccia dello stato dell’utente}: bisogna tenere conto infatti, tra le altre cose, della directory del file system remoto in cui si trova l'utente!\newline\newline
Concludiamo menzionando il fatto che esistono server che supportano connessioni FTP \textbf{senza autenticazione} (\textbf{Anonymous FTP}).  Tipicamente consentono di accedere \textbf{solo} ad una parte del file system e permettono \textbf{solo} un subset di operazioni (e.g. la PUT \textbf{non} è permessa). Di solito \textbf{si usa} un \textbf{username comune} (solitamente "ftp" or "anonymous") e una \textbf{password qualsiasi} (e.g. l'indirizzo email dell'utente).\textit{ Erano usate per distribuire a un pubblico dei file senza dover generare numerosi username e password.}
\begin{table}[h!]
	\begin{center}
		\label{tab:table1}
		\begin{tabular}{l|c|r}
			\textbf{Comandi di controllo} & \textbf{Significato}             \\
			\hline
			USER                          & username                         \\
			PASS                          & password                         \\
			LIST                          & elenca i file della
			directory corrente                                               \\
			NLST                          & richiede elenco file e
			directory (ls)                                                   \\
			RETR filename                 & recupera (get)
			un file dalla directory
			corrente                                                         \\
			STOR filename                 & memorizza
			(put) un file nell’host remoto                                   \\
			ABOR                          & interrompe l’ultimo
			comando ed i trasferimenti in
			corso                                                            \\
			PORT                          & indirizzo e numero di porta
			del client                                                       \\
			SYST                          & il server restituisce il tipo di
			sistema                                                          \\
			QUIT                          & (quit) chiude la
			connessione                                                      \\
		\end{tabular}
	\end{center}
\end{table}
\newpage
\subsubsection{DNS}
Sappiamo oramai che i dispositivi connessi in rete vengono individuati dai protocolli TCP/IP mediante i loro \textbf{indirizzi IP}, gli utenti, d'altro canto, preferiscono usare dei \textbf{nomi} invece che degli indirizzi numerici. Un \textbf{nome} identifica un \textbf{oggetto} mentre un \textbf{indirizzo} specifica \textbf{dove} l'oggetto è situato.\newline\newline
\textit{Come fare per associare i nomi agli indirizzi?}\newline\newline
Agli albori di Internet l’associazione tra nomi logici e indirizzi IP era statica!
Tutti i nomi \textit{logici} e i relativi indirizzi IP erano contenuti in un file chiamato \textbf{host file} e periodicamente tutti gli host ne prelevavano una versione aggiornata, chiamata a sua volta \textbf{master host file}, da un server ufficiale.\newline
A noi utenti moderni però dovrebbe immediatamente saltare all'occhio la seguente \textbf{problematica}: le \textbf{dimensioni attuali di Internet} rendono questo approccio \textbf{impraticabile}. Non sarebbe infatti possibile che ogni host possegga una \textbf{copia aggiornata} di un elenco del genere, in più la dimensione di questo  sarebbe sterminata, per non parlare del \textbf{volume di traffico} sul server ufficiale, il pericolo dovuto alla presenza di un \textbf{unico punto di fallimento} e l'\textbf{impossibilità di scalare} di questo sistema.\newline
Fu così che all'inizio degli anni '80 venne ideato il \textbf{DNS} o \textbf{Domain Name System}. L'\textbf{idea centrale} è di \textbf{suddividere} la sconfinata mole di associazioni nome-indirizzo e \textbf{distribuirne} le varie parti su \textbf{calcolatori sparsi per il mondo}. \textit{Come funziona? Così:}
\begin{figure}[!h]
	\includegraphics[scale=0.8]{Immagini/DNS.png}
	\centering
\end{figure}\newline
Supponiamo che un utente utilizzi un client di trasferimento file per accedere a un file su un server. L'utente conoscerà solo il \textbf{nome} del server e.g. \textit{cheneso.com}, lo \textbf{stack TCP/IP} invece ha bisogno dell'\textbf{indirizzo IP} del server per stabilire una connessione. Alla pagina seguente troviamo i sei passi necessari per \textbf{associare} l'\textbf{indirizzo} IP al \textbf{nome} del server.
\newpage
\begin{enumerate}
	\item L'\textbf{utente} comunica il nome del server al client di trasferimento file.
	\item \textbf{Il client di trasferimento file} trasmette il nome del server al \textbf{client DNS}.
	\item \textbf{Qualsiasi computer una volta avviato conosce l'indirizzo IP di un server DNS}, il \textbf{client DNS} invia dunque al \textbf{server DNS} la richiesta di traduzione del nome simbolico del server.
	\item Il \textbf{server DNS} risponde con l'indirizzo IP del server desiderato.
	\item Il \textbf{client DNS} comunica al \textbf{client di trasferimento file} l'indirizzo IP del server.
	\item Il \textbf{client di trasferimento file} \textbf{utilizza} così l'\textbf{indirizzo IP ricevuto} per accedere al server.
\end{enumerate}
Per far sì che questo meccanismo funzioni bisogna \textbf{eliminare le ambiguità sui nomi} e per far ciò si è definito uno \textbf{spazio dei nomi}. Lo \textbf{spazio dei nomi} ha una \textbf{struttura gerarchica} per una ragione principale: se tutti i nomi fossero composti da una sola stringa alfanumerica servirebbe un'\textbf{autorità centrale} che controllasse l'unicità di ogni singolo nome. Una \textbf{struttura gerarchica} consente invece di avere nomi composti da diverse parti e di \textbf{delegare il controllo} su ciascuna parte a enti o società diverse, \textbf{decentralizzando} in tal modo il processo di controllo.
\begin{figure}[!h]
	\includegraphics[scale=0.7]{Immagini/DNSpace.png}
	\centering
	\caption{In figura lo spazio dei nomi di dominio.}
\end{figure}\newline
Nello \textbf{spazio dei nomi di dominio} i nomi hanno una struttura ad \textbf{albero} con la radice in cima e un numero di livelli compreso tra 0 e 127. Ogni nodo è individuato da un'\textbf{etichetta} costituita da \textbf{massimo 63 caratteri} (\textit{la radice ha l'etichetta vuota}), tutti i nodi collegati a uno stesso nodo da rami diversi hanno etichette \textbf{diverse}, ciò garantisce l'\textbf{univocità} dei nomi. Ogni nodo dell'albero ha inoltre un \textbf{nome di dominio}, che, se letto da sinistra verso destra, è costituito da tutte le etichette, separate da punti, di tutti i nodi a partire dal nodo stesso fino alla radice, la cui etichetta è la stringa \textbf{nulla}. Immediatamente sotto la radice si trovano i \textbf{domini top-level}.
\newpage
\begin{figure}[!h]
	\includegraphics[scale=0.7]{Immagini/Etichette_dns.png}
	\centering
	\caption{In figura le etichette e i nomi di dominio.}
\end{figure}
\theoremstyle{definition}
\begin{definition}
	Un \textbf{dominio} è un \textbf{sottoalbero} dello spazio dei nomi che viene identificato dal \textbf{nome di dominio} della sua radice.
\end{definition}
\textit{Ma dove sono contenute le informazioni relative allo spazio dei nomi di dominio?}

\begin{figure}[!h]
	\includegraphics[scale=0.6]{Immagini/Dnserver.png}
	\centering
	\caption{In figura la gerarchia dei name server.}
\end{figure}
All'interno dei \textbf{DNS-Servers} o \textbf{name servers}. L'intero spazio dei nomi è stato \textbf{diviso} in diversi domini, differenziati al \textbf{top-level}, e i domini così ottenuti sono stati divisi a loro volta ottenendo dei sotto domini. Ogni \textbf{name server} è responsabile di un dominio o di un sottodominio. Vi è quindi una \textbf{gerarchia di server}. Una \textbf{zona} \textbf{è tutto ciò di cui è responsabile un server}, se un server è responsabile di un dominio e non effettua suddivisioni in sottodomini, allora la sua zona e il suo dominio \textbf{coincidono}. Se invece il server suddivide il proprio dominio in sottodomini la sua zona e il suo dominio \textbf{differiscono}. Ogni name-server ha un database chiamato \textbf{file di zona} contenente le informazioni su tutti i nodi che ricadono nella \textbf{sua} \textbf{zona} di competenza. \newpage Un \textbf{root server} è un server che ha per zona l'\textbf{intero albero dello spazio dei nomi}.\newline Solitamente i \textbf{root server} si limitano a immagazzinare riferimenti relativi ad altri server e \textbf{delegano} loro tutte le responsabilità.\newline
Esempio di top-level domains:
\begin{table}[h!]
	\begin{center}
		\label{tab:table1}
		\begin{tabular}{l|c|r}
			\textbf{Dominio}     & \textbf{Uso}                            \\
			\hline
			com                  & organizzazioni commerciali              \\
			edu                  & istituti di istruzione                  \\
			mil                  & gruppi militari                         \\
			gov                  & istituzioni governative americane       \\
			net                  & principali centri di supporto alla rete \\
			org                  & organizzazioni diverse dalle precedenti \\
			it, uk, us, fr, ecc. & codice geografico per nazioni
			\\
		\end{tabular}
	\end{center}
\end{table}\newline
I \textbf{server DNS} possono essere \textbf{primari} o \textbf{secondari}.
\begin{itemize}
	\item Un server \textbf{primario} possiede sul disco e aggiorna il \textbf{file di zona} relativo alla zona sotto la sua responsabilità.
	\item Un server \textbf{secondario} riceve le informazioni relative a una zona da un \textbf{server primario}.
\end{itemize}
I \textbf{server} \textbf{primari} e \textbf{secondari} hanno la medesima autorità sulla loro zona di competenza, è bene specificare che \textbf{un server può essere primario per una zona  e secondario per un altra}, \textbf{primario} e \textbf{secondario} sono quindi aggettivi \textbf{relativi alla zona}. Si noti inoltre come l'introduzione di un server secondario in una zona porti a una duplicazione del \textbf{file di zona} che può risultare utile per eventuali guasti al \textbf{server primario}.\newline\newline
\textit{Come si associa l'indirizzo IP da un nome?}\newline\newline
Il processo con cui si associa l'indirizzo IP da un nome è detto \textbf{processo di risoluzione}. Il \textbf{protocollo DNS} è progettato come protocollo \textbf{client-server}. Un host che voglia ricavare un indirizzo IP da un nome si rivolge al \textbf{programma client} detto anche \textbf{resolver} che invierà un'opportuna richiesta al \textbf{server DNS più vicino} il quale, se dispone della risposta, invierà l'indirizzo o il nome (\textit{è infatti possibile fare il processo al contrario}), oppure inoltrerà la richiesta a un altro server o comunicherà al resolver l'indirizzo di un altro server a cui fare riferimento. Il \textbf{resolver}, ricevuta la risposta, la esaminerà per verificarne la presenza di errori e la trasmetterà al processo che l'ha effettuata. La \textbf{risoluzione} può essere \textbf{ricorsiva} o \textbf{iterativa}.
\newpage

\begin{itemize}
	\item Con la \textbf{risoluzione ricorsiva}, la \textbf{query DNS} viaggia dall'host su cui è in esecuzione il processo applicativo che ne ha fatto richiesta fino a un host che conosce l'indirizzo IP richiesto, eventualmente scalando, poi discendendo e infine percorrendo a all'indietro \textbf{l'intera gerarchia dei server DNS}. \textbf{All'host che ha richiesto la query viene inviato \textbf{solo} l'indirizzo IP risultante}. Il server locale ha richiesto quindi una \textbf{conversione completa}.
	      \begin{figure}[!h]
		      \includegraphics[scale=0.7]{Immagini/DNSrec.png}
		      \centering
		      \caption{In figura un esempio di risoluzione ricorsiva.}
	      \end{figure}
	\item Con la  \textbf{risoluzione iterativa} ogni \textbf{server-DNS} che non è in grado di risolvere la \textbf{query-DNS} dell'host risponde, \textbf{direttamente al client-DNS}, con \textbf{l'indirizzo di un altro server in grado di risolverla}.
	      \textbf{	All'host che ha richiesto la query non viene quindi inviato solo l'indirizzo IP risultante}. La \textbf{risoluzione iterativa} è supportata da \textbf{tutti} i \textbf{name server}, l'host può richiedere che venga usata la \textbf{risoluzione ricorsiva} ma potrebbe non essere disponibile.

	      \begin{figure}[!h]
		      \includegraphics[scale=0.7]{Immagini/DNSite.png}
		      \centering
		      \caption{In figura un esempio di risoluzione iterativa.}
	      \end{figure}
\end{itemize}
Ogni volta che a un \textbf{server} arriva una richiesta di risoluzione di un nome, che non fa parte del suo dominio, deve cercare, all'interno del suo database, un altro server a cui inoltrare la richiesta. Ridurre questo tempo di ricerca significa ridurre il tempo di attesa della risposta e aumentare l'efficienza. Ancora una vola ci viene in aiuto il \textbf{caching}: una volta che un \textbf{server} ha appreso un' \textbf{associazione}, la inserisce in \textbf{cache}. Il server marca le risposte prese dalla propria cache come \textbf{unauthoritative} o non autorevole.
\newpage
Dopo un certo lasso di tempo chiamato \textbf{TTL} o \textbf{time to live} il server cancella dalla cache l'associazione per evitare l'invio di risposte obsolete.\newline\newline
\textit{Ma come è fatto quindi il database di un server?}\newline\newline
Il \textbf{database del server} non è altro che una collezione di \textbf{records} strutturati nel seguente modo:\newline\newline
\centerline{\textbf{(Nome di dominio, Tipo, Classe, TTL, Valore)}}\newline\newline
A ogni \textbf{nome di dominio}, quindi a ogni \textbf{nodo dell'albero dello spazio dei nomi di dominio}, è associato un record composto da 5 campi.
\begin{itemize}
	\item \textbf{Nome di dominio} identifica il record della risorsa.
	\item \textbf{Tipo} definisce come interpretare il campo \textbf{Valore}.
	\item \textbf{Classe} definisce il tipo di rete, IN sta per Internet.
	\item \textbf{TTL} indica il numero di secondi per cui l'informazione deve essere ritenuta valida
	\item \textbf{Valore} contiene l'informazione memorizzata relativa al \textbf{nome di dominio}.
\end{itemize}
Di seguito i \textbf{tipi} dei \textbf{record}:
\begin{table}[h!]
	\begin{center}
		\label{tab:table1}
		\begin{tabular}{l|c|r}
			\textbf{Tipo} & \textbf{Interpretazione}                           \\
			\hline
			A             & indirizzo Ipv4 a 32 bit                            \\
			NS            & identifica i server autoritativi di una zona       \\
			CNAME         & il nome di dominio è un alias per quello ufficiale \\
			SOA           & informazioni autoritative riguardanti una zona     \\
			MX            & server di posta del dominio
			corrente                                                           \\
			AAAA          & indirizzo Ipv6                                     \\
		\end{tabular}
	\end{center}
\end{table}\newline
\textit{Che protocollo di livello trasporto è usato?}\newline\newline
Il sistema DNS può usare \textbf{sia} il \textbf{il protocollo TCP} che l'\textbf{UDP}.
Il \textbf{protocollo UDP} viene usato \textbf{quando} la dimensione del messaggio di risposta è \textbf{inferiore} a\textbf{ 512 byte}, molto spesso infatti i \textbf{datagrammi utente UDP} non possono superare i 512 byte come dimensione massima. In caso contrario si usa il \textbf{protocollo TCP}.\newline\newline
\textit{Come si aggiungono nuovi domini al DNS?}\newline\newline Pagando i \textbf{registrar}, ovvero aziende commerciali accreditate dall'ICANN.\newpage
\textit{Come sono fatti i messaggi DNS?}\newline\newline
I \textbf{messaggi DNS} posso essere di \textbf{due tipi}: di \textbf{interrogazione} o di \textbf{risposta} e i due tipi hanno lo \textbf{stesso} formato.
\begin{figure}[!h]
	\includegraphics[scale=0.6]{Immagini/DNSmessage.png}
	\centering
	\caption{La struttura dei messaggi DNS, il messaggio interrogazione contiene solo la sezione richiesta mentre il messaggio di risposta contiene la sezione richiesta, la sezione risposta ed eventualmente le altre due.}
\end{figure}\newline
Descriviamo ora brevemente i vari campi situati prima dell'\textbf{intestazione} lunga \textbf{12 bytes}:
\begin{itemize}
	\item \textbf{Identificazione} è il campo usato dal \textbf{client} per associare la risposta all'interrogazione.
	\item Il campo \textbf{Flag} indica se si tratta di un messaggio di richiesta o di risposta e segnala inoltre la presenza di eventuali errori.
	\item I \textbf{quattro} campi successivi dell'\textbf{intestazione} specificano il numero di ciascun tipo di record presente nel messaggio.
\end{itemize}
Poi del \textbf{messaggio}:
\begin{itemize}
	\item La \textbf{sezione di richiesta} che è inclusa nell'interrogazione e poi ripetuta anche nel messaggio di risposta è \textbf{formata} da\textbf{ uno o più record di richiesta}.
	\item La \textbf{sezione di risposta} è presente \textbf{esclusivamente} nei messaggi di risposta consiste \textbf{in uno o più record di risorsa}
	\item La \textbf{sezione autoritativa} fornisce le informazioni di uno o più server autorevoli per l'interrogazione.
	\item La \textbf{sezione supplementare} contiene \textbf{informazioni aggiuntive} che potrebbero essere \textbf{utili} al \textbf{client DNS}.
\end{itemize}
\textit{In UNIX si può utilizzare il comando} \texttt{nslookup} \textit{per ottenere associazioni nome simbolico : indirizzo numerico.}
\end{document}






